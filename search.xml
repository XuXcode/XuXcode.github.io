<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面向对象之——多态</title>
      <link href="/2025/12/20/%E5%A4%9A%E6%80%81/"/>
      <url>/2025/12/20/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="1-认识多态"><a href="#1-认识多态" class="headerlink" title="1.认识多态"></a>1.认识多态</h2><h3 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h3><ul><li>多态是在<font color=red>继承&#x2F;实现</font>情况下的一种现象，表现为：对象多态、行为多态。</li></ul><h4 id="多态的具体代码体现："><a href="#多态的具体代码体现：" class="headerlink" title="多态的具体代码体现："></a><strong>多态的具体代码体现：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">People p1= <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">r1.run();</span><br><span class="line"></span><br><span class="line">People p2=<span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">p2.run();</span><br></pre></td></tr></table></figure><h3 id="多态的前提："><a href="#多态的前提：" class="headerlink" title="多态的前提："></a>多态的前提：</h3><ul><li>有<font color=red>继承&#x2F;实现</font>关系；</li><li>存在父类引用子类对象；</li><li><font color=red>存在方法重写</font>。&#x2F;&#x2F;导致每个对象的行为不一样</li></ul><h3 id="多态的一个注意事项"><a href="#多态的一个注意事项" class="headerlink" title="多态的一个注意事项"></a>多态的一个注意事项</h3><ul><li>多态是对象、行为的多态</li><li>Java中的属性(成员变量)不谈多态。<ul><li>对于方法：编译看左边，运行看右边；</li><li>对于成员变量：编译看左边，运行也看左边。</li></ul></li></ul><hr><h2 id="2-多态的好处"><a href="#2-多态的好处" class="headerlink" title="2.多态的好处"></a>2.多态的好处</h2><h3 id="使用多态的好处"><a href="#使用多态的好处" class="headerlink" title="使用多态的好处"></a>使用多态的好处</h3><ul><li><p>在多态形式下，右边对象是解耦合(模块化)的，更便于扩展和维护</p></li><li><p>定义方法时，使用父亲类型的形参，可以接收一切子类对象，扩展性更强、更便利。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Animal a1=<span class="keyword">new</span> <span class="title class_">Sheep</span>();</span><br><span class="line">        a1.run();</span><br><span class="line">        go(a1);</span><br><span class="line">        Animal a2=<span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">        a2.run();</span><br><span class="line">        go(a2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Animal a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始。。。&quot;</span>);</span><br><span class="line">        a.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态下会产生的一个问题"><a href="#多态下会产生的一个问题" class="headerlink" title="多态下会产生的一个问题"></a>多态下会产生的一个问题</h3><ul><li>多态下不能使用子类的独有功能。</li></ul><hr><h2 id="3-多态下的类型转换"><a href="#3-多态下的类型转换" class="headerlink" title="3.多态下的类型转换"></a>3.多态下的类型转换</h2><h3 id="转换形式："><a href="#转换形式：" class="headerlink" title="转换形式："></a>转换形式：</h3><ul><li>自动类型转换：父类 变量名 &#x3D;new 子类();</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People p=<span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br></pre></td></tr></table></figure><ul><li>强制类型转换：<font color=red>子类 变量名&#x3D;(子类)父类变量</font><ul><li>解决多态下调用子类独有功能。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher t=(Teacher)p;</span><br></pre></td></tr></table></figure><h3 id="强制转换的一个注意事项："><a href="#强制转换的一个注意事项：" class="headerlink" title="强制转换的一个注意事项："></a>强制转换的一个注意事项：</h3><ul><li>存在继承&#x2F;实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。</li><li>运行时，如果发现对象的真实类型与强转后的类型不同，就会类型转换异常(ClassCastException)的错误出来。</li></ul><h5 id="强转前，Java建议："><a href="#强转前，Java建议：" class="headerlink" title="强转前，Java建议："></a>强转前，Java建议：</h5><ul><li>使用 <strong>instanceof</strong> 关键字，判断当前对象的真实类型，在进行强转。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">instanceof</span> Student</span><br><span class="line"><span class="comment">//对象 instanceif 类型</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的基本语法</title>
      <link href="/2025/12/20/%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/12/20/%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="类的基本语法"><a href="#类的基本语法" class="headerlink" title="类的基本语法"></a>类的基本语法</h1><blockquote><p>Java learning note</p><p>Written by XuX</p></blockquote><h2 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1.构造器"></a>1.构造器</h2><p>构造器，就是名字和类名一致，并且没有定义返回值的一种特殊方法。</p><h4 id="构造器长什么样？如下代码所示："><a href="#构造器长什么样？如下代码所示：" class="headerlink" title="构造器长什么样？如下代码所示："></a>构造器长什么样？如下代码所示：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参数构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">/*类中的构造器*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123; <span class="comment">//只有修饰符，没有返回值（特殊形式）</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.有参数构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器有什么特点呢？"><a href="#构造器有什么特点呢？" class="headerlink" title="构造器有什么特点呢？"></a>构造器有什么特点呢？</h4><p>创建对象时，<u>对象会调用构造器</u>，我们可以指定对象去调用哪个构造器去执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">Student s=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><h4 id="构造器的常见应用场景："><a href="#构造器的常见应用场景：" class="headerlink" title="构造器的常见应用场景："></a>构造器的常见应用场景：</h4><p>创建对象时，同时完成对对象成员变量(属性)的初始化赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="comment">//有参数构造器：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String n,<span class="type">int</span> a,<span class="type">char</span> g)</span>&#123;</span><br><span class="line">        name=n;</span><br><span class="line">        age=a;</span><br><span class="line">        gender=g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象调用：</span></span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;kobe&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="构造器的注意事项："><a href="#构造器的注意事项：" class="headerlink" title="构造器的注意事项："></a>构造器的注意事项：</h4><p>1.类默认就自带了一个无参构造器；</p><p>2.如果为类定义了有参数构造器，类默认的无参数构造器就没有了，若还想用无参数构造器，就必须自己手写一个无参数构造器出来。</p><p>3.要么都不写，要么都写（无参数在开发中别人可能会使用）</p><hr><h2 id="2-this关键字"><a href="#2-this关键字" class="headerlink" title="2. this关键字"></a>2. this关键字</h2><h4 id="this-关键字是什么？"><a href="#this-关键字是什么？" class="headerlink" title="this 关键字是什么？"></a>this 关键字是什么？</h4><p>this就是一个变量，可以用在方法中，来拿到当前对象</p><p><u>哪个对象调用这个方法，this就拿到哪个对象(取地址)</u></p><h4 id="this有哪些应用场景？"><a href="#this有哪些应用场景？" class="headerlink" title="this有哪些应用场景？"></a>this有哪些应用场景？</h4><p>this主要用来<u>解决：变量名称冲突问题</u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name; <span class="comment">//成员变量(整个对象都可以用)    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHobby</span><span class="params">(String name)</span>&#123; <span class="comment">//局部变量(方法内部)</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;喜欢&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h2><h4 id="什么是封装？"><a href="#什么是封装？" class="headerlink" title="什么是封装？"></a>什么是封装？</h4><p>就是用类设计对象处理某一个事务的数据时，应该把要处理的数据，以及处理这些数据的方法，设计到一个对象中去</p><p><em><em>面向对象的三大特征：<strong>封装</strong>，继承，多态</em></em></p><h4 id="封装的设计要求："><a href="#封装的设计要求：" class="headerlink" title="封装的设计要求："></a>封装的设计要求：</h4><p>合理隐藏，合理暴露。</p><h5 id="1-如何隐藏对象的成员？"><a href="#1-如何隐藏对象的成员？" class="headerlink" title="1.如何隐藏对象的成员？"></a>1.如何隐藏对象的成员？</h5><p>使用private关键字(私有，隐藏)修饰成员变量，就只能在本类中被直接访问，其他任何地方不能直接访问</p><h5 id="2-如何暴露对象的成员（合理暴露）？"><a href="#2-如何暴露对象的成员（合理暴露）？" class="headerlink" title="2.如何暴露对象的成员（合理暴露）？"></a>2.如何暴露对象的成员（合理暴露）？</h5><p>使用public(公开)的get和set方法合理暴露，成员变量的取值和赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="comment">//1.为年龄赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(age&gt;<span class="number">0</span>&amp;&amp;age&lt;<span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您赋值的年龄数据非法！&quot;</span>);   <span class="comment">//例如web端对于输入的年龄的校验</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用：</span></span><br><span class="line">s1.setAge(<span class="number">18</span>); <span class="comment">//赋值18；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.为年龄取值：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用：</span></span><br><span class="line">System.out.println(s1.getAge()); <span class="comment">//取值</span></span><br></pre></td></tr></table></figure><h5 id="总结（代码层面如何控对象的成员的公开与与隐藏？）"><a href="#总结（代码层面如何控对象的成员的公开与与隐藏？）" class="headerlink" title="总结（代码层面如何控对象的成员的公开与与隐藏？）:"></a>总结（代码层面如何控对象的成员的公开与与隐藏？）:</h5><ul><li>公开成员，可以使用public(公开)进行修饰。</li><li>隐藏成员，使用private(私有，隐藏)进行修饰</li></ul><hr><h2 id="4-实体类-特殊类-Javabean"><a href="#4-实体类-特殊类-Javabean" class="headerlink" title="4.实体类(特殊类) Javabean"></a>4.实体类(特殊类) Javabean</h2><h4 id="1-是一种特殊类，类中要满足如下需求："><a href="#1-是一种特殊类，类中要满足如下需求：" class="headerlink" title="1.是一种特殊类，类中要满足如下需求："></a>1.是一种特殊类，类中要满足如下需求：</h4><p>1.类中的成员变量全部私有，并提供public修饰的getter&#x2F;setter方法；</p><p>2.类中要提供一个无参数的构造器，有参数构造器可选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实体类的作用：创建它的对象，存取（封装）数据</span></span><br><span class="line">        <span class="comment">//调用无参构造器的对象</span></span><br><span class="line">        Student s=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//调用有参构造器的对象</span></span><br><span class="line">        Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//2.提供公平的getter和setter方法，暴露其取值和赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须提供一个无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个有参构造器（可选）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-实体类有啥应用场景？"><a href="#2-实体类有啥应用场景？" class="headerlink" title="2.实体类有啥应用场景？"></a>2.实体类有啥应用场景？</h4><ul><li>实体类的对象<u>只负责数据读取</u>，而对数据的业务处理交给其他类的对象来完成，以<u>实现数据</u>和<u>数据业务处理</u>相分离。(分层思想)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student s; <span class="comment">//用来记住将来要操作的学生对象 （null）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentOperator</span><span class="params">(Student s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Student=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印总成绩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> printscore&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印平均成绩</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        <span class="comment">//创建一个学生的操作对象专门负责对学生对象的数据进行业务分析</span></span><br><span class="line">        StudentOperate op=<span class="keyword">new</span> <span class="title class_">StudentOperate</span>(s1);</span><br><span class="line">        op.printscore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><h4 id="1-什么是实体类？有什么特点？"><a href="#1-什么是实体类？有什么特点？" class="headerlink" title="1.什么是实体类？有什么特点？"></a>1.什么是实体类？有什么特点？</h4><ul><li>成员变量必须私有，且要为它们提供get、set方法；必须有无参数构造器</li><li>仅仅是一个用来保存数据的Java类，可以用它来创建对象，保存某个事物的数据</li></ul><h4 id="2-实体类的应用场景-如上"><a href="#2-实体类的应用场景-如上" class="headerlink" title="2.实体类的应用场景(如上)"></a>2.实体类的应用场景(如上)</h4><hr><h2 id="4-static"><a href="#4-static" class="headerlink" title="4. static"></a>4. static</h2><h3 id="1-static-修饰成员变量"><a href="#1-static-修饰成员变量" class="headerlink" title="1. static 修饰成员变量"></a>1. static 修饰成员变量</h3><h4 id="成员变量按照有无static修饰，分为两种："><a href="#成员变量按照有无static修饰，分为两种：" class="headerlink" title="成员变量按照有无static修饰，分为两种："></a>成员变量按照有无static修饰，分为两种：</h4><ul><li><p>静态变量（类变量）：有static修饰，属于类，在计算机里只有一份，会被类的全部对象共享。</p><p><u>访问方式：类名.静态对象</u></p><p>也可以以“对象名.静态变量”的方式（语法上不推荐 ）</p></li><li><p>实例变量（对象的变量）：无static修饰，属于每个对象的。</p><p><u>访问方式：对象.实例变量</u></p><p><mark>注意：不允许使用this关键字</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量：属于类，只加载一份，可以被类和类的全部对象共享访问</span></span><br><span class="line">    <span class="keyword">static</span> String name;  <span class="comment">//先进入堆内存null</span></span><br><span class="line">    <span class="comment">//实例变量（对象的变量）：属于对象，每个对象一份</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="静态变量应用场景："><a href="#静态变量应用场景：" class="headerlink" title="静态变量应用场景："></a>静态变量应用场景：</h4><ul><li><p>如果某个数据只需要一份，且希望能够被共享（修改&#x2F;访问），则该数据可以定义为静态变量来记住</p></li><li><p>例如：记录用户类创建了多少用户对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        User.number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问自己类中的类变量，可以省略类名不写"><a href="#访问自己类中的类变量，可以省略类名不写" class="headerlink" title="访问自己类中的类变量，可以省略类名不写"></a>访问自己类中的类变量，可以省略类名不写</h4><p>注意：在某类中访问其他类里的类变量必须带类名访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String school=<span class="string">&quot;HUT&quot;</span>;<span class="comment">//类变量（静态变量）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSchool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//本类内访问类变量，可省略类名Student</span></span><br><span class="line">        System.out.println(school);</span><br><span class="line">                         <span class="comment">//等价于Student.school</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-static修饰方法"><a href="#2-static修饰方法" class="headerlink" title="2. static修饰方法"></a>2. static修饰方法</h3><h4 id="使用规范："><a href="#使用规范：" class="headerlink" title="使用规范："></a>使用规范：</h4><p><mark>1.如果这个方法只是为了做一个功能且不需要直接访问对象的数据，那么这个方法应该定义为静态方法</mark></p><p><mark>2.如果这个方法是对象的行为，需要访问对象数据，那么这个方法应该定义为实例方法</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//认识 static修饰与不修饰方法的区别</span></span><br><span class="line">        <span class="comment">//1.类名.静态方法（推荐）</span></span><br><span class="line">        Student.printHelloWorld();</span><br><span class="line">        <span class="comment">//2.对象.静态方法（不推荐）</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.printHelloWorld();</span><br><span class="line">        <span class="comment">//3.对象名.实例方法</span></span><br><span class="line">        <span class="comment">//Student.printPass(); //报错</span></span><br><span class="line">        s1.setScore(<span class="number">59.9</span>);</span><br><span class="line">        s1.printPass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//静态方法:有static修饰，属于类持有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例方法:无static修饰，属于对象持有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPass</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(score&gt;=<span class="number">60</span>?<span class="string">&quot;通过&quot;</span>:<span class="string">&quot;挂科了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态方法的应用"><a href="#3-静态方法的应用" class="headerlink" title="3.静态方法的应用"></a>3.静态方法的应用</h3><h4 id="静态方法常见的应用场景"><a href="#静态方法常见的应用场景" class="headerlink" title="静态方法常见的应用场景"></a>静态方法常见的应用场景</h4><ul><li>做工具类</li></ul><h4 id="工具类是什么？"><a href="#工具类是什么？" class="headerlink" title="工具类是什么？"></a>工具类是什么？</h4><ul><li>工具类中的方法都是一些静态方法，每个方法用来完成一项功能，以便于开发者直接使用。</li></ul><h4 id="使用类方法来设计工具类有啥好处？"><a href="#使用类方法来设计工具类有啥好处？" class="headerlink" title="使用类方法来设计工具类有啥好处？"></a>使用类方法来设计工具类有啥好处？</h4><ul><li>提高了代码复用；</li><li>调用方便，提高了开发的效率</li></ul><p><strong>注意：<u>工具类没有创建对象的需求（占内存），建议将工具类的构造器进行私有</u></strong></p><h3 id="4-static的注意事项"><a href="#4-static的注意事项" class="headerlink" title="4. static的注意事项"></a>4. static的注意事项</h3><ul><li>静态方法中可以直接访问静态成员不可以直接访问实例成员</li><li>实例方法中既可以直接访问静态成员，也可以直接访问实例成员</li><li>实例方法中可以出现this关键字，静态方法中不可以出现this关键字的</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象之——继承</title>
      <link href="/2025/12/20/%E7%BB%A7%E6%89%BF/"/>
      <url>/2025/12/20/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="1-认识继承"><a href="#1-认识继承" class="headerlink" title="1.认识继承"></a>1.认识继承</h2><h3 id="为什么要有继承？"><a href="#为什么要有继承？" class="headerlink" title="为什么要有继承？"></a>为什么要有继承？</h3><ul><li>提高代码的重用性，减少一点重复代码的书写</li></ul><h3 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a>什么是继承？</h3><ul><li>Java中提供了一个关键字extends，用这个关键字，可以让一个类与另一个类建立起父子关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//A类称为父类（基类或超类）</span></span><br><span class="line">    <span class="comment">//B类称为子类（派生类）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子类能继承啥？"><a href="#子类能继承啥？" class="headerlink" title="子类能继承啥？"></a>子类能继承啥？</h4><ul><li>子类能继承父类的非私有成员变量（成员变量、成员方法）</li></ul><h4 id="继承后对象的创建"><a href="#继承后对象的创建" class="headerlink" title="继承后对象的创建"></a>继承后对象的创建</h4><ul><li>子类的对象是由子类、父类共同完成的。</li></ul><hr><h2 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2.权限修饰符"></a>2.权限修饰符</h2><h3 id="什么是权限修饰符？"><a href="#什么是权限修饰符？" class="headerlink" title="什么是权限修饰符？"></a>什么是权限修饰符？</h3><ul><li><p>就是用来限制类中的成员（成员变量、成员方法、构造器）能够访问的范围。</p><p><mark>private</mark>：只能本类</p><p><mark>缺省(不写任何权限修饰符，默认权限)</mark>：本类、同一个包中的类</p><p><mark>protected</mark>：本类，同一个包的类，子孙类中</p><p><mark>public</mark>：任意位置</p></li></ul><hr><h2 id="3-继承的特点"><a href="#3-继承的特点" class="headerlink" title="3.继承的特点"></a>3.继承的特点</h2><h3 id="1-单继承"><a href="#1-单继承" class="headerlink" title="1)单继承"></a>1)单继承</h3><ul><li>Java是单继承模式：一个类只能继承一个直接父类</li></ul><h3 id="2-多层继承"><a href="#2-多层继承" class="headerlink" title="2)多层继承"></a>2)多层继承</h3><ul><li>Java不支持多继承，但支持多层继承</li></ul><h3 id="3-祖宗类"><a href="#3-祖宗类" class="headerlink" title="3)祖宗类"></a>3)祖宗类</h3><ul><li>Java中所有的类都是Object的子类，Object是所有类的祖宗类</li><li>Java中所有类，要么直接继承了Object，要么默认继承了Object，要么间接继承了Object</li></ul><h3 id="4-就近原则"><a href="#4-就近原则" class="headerlink" title="4)就近原则"></a>4)就近原则</h3><h4 id="1、子类方法中访问其他成员（成员变量、成员方法），依照就近原则"><a href="#1、子类方法中访问其他成员（成员变量、成员方法），依照就近原则" class="headerlink" title="1、子类方法中访问其他成员（成员变量、成员方法），依照就近原则"></a>1、子类方法中访问其他成员（成员变量、成员方法），依照就近原则</h4><ul><li>优先访问自己类中，自己类中的没有才会访问父类</li><li>先子类的局部范围找，然后子类的成员范围找，然后父类成员范围找，如果父类范围没找到就报错。</li></ul><h4 id="2、如果子父类，出现了重名的成员，会优先使用子类的，如果一定要在子类中使用父类的怎么办？"><a href="#2、如果子父类，出现了重名的成员，会优先使用子类的，如果一定要在子类中使用父类的怎么办？" class="headerlink" title="2、如果子父类，出现了重名的成员，会优先使用子类的，如果一定要在子类中使用父类的怎么办？"></a>2、如果子父类，出现了重名的成员，会优先使用子类的，如果一定要在子类中使用父类的怎么办？</h4><ul><li>可以使用<font color=red>super关键字</font>，指定访问父类的成员：</li></ul><p>​        <font color=red><strong>super.父类成员变量&#x2F;父类成员方法</strong></font></p><hr><h2 id="4-方法重写"><a href="#4-方法重写" class="headerlink" title="4.方法重写"></a>4.方法重写</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>当子类觉得父类中的某个方法不好用，或者是无法满足自己的需求时，子类可以重写一个<u>方法名称、参数列表一样的方法</u>，去覆盖父类这个方法，这就是方法重写。</p></li><li><p>方法名称，形参列表必须一样，这种方法就是方法重写。</p></li></ul><h3 id="重写小技巧："><a href="#重写小技巧：" class="headerlink" title="重写小技巧："></a>重写小技巧：</h3><ul><li>使用<font color=red>Override注解</font>，它可以指定Java编译器，检查我们的方法重写格式是否正确，代码的可读性也会更好。</li><li>声明不变，重新实现。</li></ul><h3 id="方法重写的其他注意事项"><a href="#方法重写的其他注意事项" class="headerlink" title="方法重写的其他注意事项"></a>方法重写的其他注意事项</h3><ul><li>子类重写父类方法时，访问权限必须大于或等于父类该方法的权限<font  color=red>(public&gt;protected&gt;缺省)</font></li><li>重写的方法返回值类型，必须与重写方法的返回值类型一样，或者范围更小。</li><li>私有方法、静态方法不能被重写，如果重写会报错。</li></ul><h3 id="方法重写再开发中的常见应用场景"><a href="#方法重写再开发中的常见应用场景" class="headerlink" title="方法重写再开发中的常见应用场景"></a>方法重写再开发中的常见应用场景</h3><ul><li><p>子类重写Object类的toString()方法，以便返回对象的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student s=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;kobe&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(s.toString());</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//注意1：直接输出对象，默认会调用toString方法，返回对象的地址信息</span></span><br><span class="line">        <span class="comment">//注意2：输出对象的地址没有意义，开发中更希望看到的是对象的信息，所以子类需要重写Object的toString方法</span></span><br><span class="line">        <span class="comment">//      以便以后输出对象时默认调用子类重写的toSring方法返回对象的内容。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, gender=&quot;</span> + gender +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意1：直接输出对象，默认会调用toString方法，返回对象的地址信息</p></li><li><p>注意2：输出对象的地址没有意义，开发中更希望看到的是对象的信息，所以子类需要重写Object的toString方法，以便以后输出对象时默认调用子类重写的toSring方法返回对象的内容。</p></li></ul><hr><h2 id="5-子类构造器的特点"><a href="#5-子类构造器的特点" class="headerlink" title="5.子类构造器的特点"></a>5.子类构造器的特点</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>子类的全部构造器，都会先调用父类的构造器，再执行自己。</li></ul><h3 id="子类构造器是如何实现调用父类构造器的："><a href="#子类构造器是如何实现调用父类构造器的：" class="headerlink" title="子类构造器是如何实现调用父类构造器的："></a>子类构造器是如何实现调用父类构造器的：</h3><ul><li><p>默认情况下，子类全部构造器的第一行代码都是<font color=red>super()（写不写都有），它会调用父类的无参数构造器</font></p></li><li><p>如果父类没有无参数构造器，则我们必须在子类构造器第一行手写super(…)，指定去调用父类的有参数构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//子类构造器都会先调用父类无参数构造器，再执行自己的构造器</span></span><br><span class="line">        Zi zi=<span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">666</span>); <span class="comment">//指定调用父类的有参构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类有参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="子类构造器调用父类构造器的应用场景"><a href="#子类构造器调用父类构造器的应用场景" class="headerlink" title="子类构造器调用父类构造器的应用场景"></a>子类构造器调用父类构造器的应用场景</h3><ul><li>子类构造器可以通过调用父类构造器，把对象中包含父类这部分的数据先初始化赋值。</li><li>再回来把对象里包含子类这部分的数据也进行初始化赋值。</li></ul><h3 id="补充知识：this-…-调用兄弟构造器"><a href="#补充知识：this-…-调用兄弟构造器" class="headerlink" title="补充知识：this(…)调用兄弟构造器"></a>补充知识：this(…)调用兄弟构造器</h3><ul><li><p>任意类的构造器中，是可以通过this(…)去调用该类的其他构造器的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> gender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name,age,gender,<span class="string">&quot;HUT&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：super(…)和this(…)必须写在构造器的第一行，而且两者不能同时出现。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
