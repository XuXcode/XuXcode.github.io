<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象高级语法</title>
      <link href="/2025/12/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
      <url>/2025/12/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象高级"><a href="#面向对象高级" class="headerlink" title="面向对象高级"></a>面向对象高级</h1><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><h3 id="1-认识final关键字"><a href="#1-认识final关键字" class="headerlink" title="1.认识final关键字"></a>1.认识final关键字</h3><p>final关键字时最终的意思，可以修饰：类、方法、变量。</p><ul><li><p>修饰类：该类被称为最终类，特点是不能被继承了。</p></li><li><p>修饰方法：该方法被称为最终方法，特点是不能被重写了。</p></li><li><p>修饰变量：该变量有且仅能被赋值一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> PI=<span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><ul><li>final修饰静态变量，这个变量今后被称为常量，可以记住一个固定值，并且程序中不能修改了，通常这个值作为系统的配置信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL=<span class="string">&quot;HUT&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>变量：</p><p>a.成员变量：写在类中的变量</p><p>​        又分为：静态成员变量，实例成员变量。</p><p>b.局部变量：写在方法或循环中的变量</p></blockquote></li></ul><h3 id="2-final修饰变量的注意事项"><a href="#2-final修饰变量的注意事项" class="headerlink" title="2. final修饰变量的注意事项"></a>2. final修饰变量的注意事项</h3><ul><li>final修饰基本类型的变量，变量存储的<font color=red>数据</font>不能被改变。</li><li>final修饰引用类型的变量，变量存储的<font color=red>地址</font>不能被改变，但地址所指向对象的内容是可以被改变的（数组）。</li></ul><h3 id="3-常量"><a href="#3-常量" class="headerlink" title="3.常量"></a>3.常量</h3><h4 id="常量的概念、作用"><a href="#常量的概念、作用" class="headerlink" title="常量的概念、作用"></a>常量的概念、作用</h4><ul><li><p>使用了<font color=red>static final 修饰的成员变量就被称作常量</font></p></li><li><p>作用：<font color=red>常用于记录系统的配置信息</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL=<span class="string">&quot;HUT&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><mark>常量的名称，建议全部大写，多个单词用下划线连接。</mark></li><li>引用常量：Constant.常量名 (宏替换)</li></ul></li></ul><h4 id="使用常量记录系统配置信息的优势、执行原理"><a href="#使用常量记录系统配置信息的优势、执行原理" class="headerlink" title="使用常量记录系统配置信息的优势、执行原理"></a>使用常量记录系统配置信息的优势、执行原理</h4><ul><li>代码的可读性更好，可维护性也更好。</li><li>程序编译后，常量会被“宏替换”：出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的。</li></ul><hr><h2 id="单例类（设计模式）"><a href="#单例类（设计模式）" class="headerlink" title="单例类（设计模式）"></a>单例类（设计模式）</h2><h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h3><ul><li>一个问题多种解，其中一个方法最优且被总结出来了，称之为**设计模式 **</li><li>设计模式有20多种，对应20多种开发中遇到的问题。</li></ul><h4 id="关于设计模式，主要学什么？"><a href="#关于设计模式，主要学什么？" class="headerlink" title="关于设计模式，主要学什么？"></a>关于设计模式，主要学什么？</h4><ul><li>1.解决什么问题？</li><li>2.怎么写？</li></ul><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul><li><strong>作用</strong>：确保某个类只能创建一个对象。</li></ul><h4 id="写法，实现步骤："><a href="#写法，实现步骤：" class="headerlink" title="写法，实现步骤："></a>写法，实现步骤：</h4><ul><li>把类的构造器私有。</li><li>定义一个类变量(静态变量)记住类的一个对象。</li><li>定义一个类方法(静态方法)，返回对象。<ul><li><strong>饿汉式单例</strong>：拿对象时，对象早就创建好了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//2、定义一个类变量记住类的一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A a=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.定义一个类方法返回对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建对象：</span></span><br><span class="line">A a1=A.getObject;</span><br></pre></td></tr></table></figure><ul><li><strong>懒汉单例类：</strong><ul><li>用对象时，才开始创建对象。（延迟加载对象）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//2、定义一个类变量用于存储对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b; <span class="comment">//null</span></span><br><span class="line">    <span class="comment">//1、单例必须私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、提供一个类方法返回类的一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="literal">null</span>)&#123;</span><br><span class="line">            b=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例有啥应用场景，有啥好处？"><a href="#单例有啥应用场景，有啥好处？" class="headerlink" title="单例有啥应用场景，有啥好处？"></a>单例有啥应用场景，有啥好处？</h3><ul><li>任务管理器对象、获取运行时对象。</li><li>在这些业务场景下，使用单例模式，可以避免浪费内存。</li></ul><hr><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="认识枚举类"><a href="#认识枚举类" class="headerlink" title="认识枚举类"></a>认识枚举类</h3><ul><li>枚举类是一种特殊类。</li><li>枚举类的写法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    名称<span class="number">1</span>，名称<span class="number">2</span>，...;</span><br><span class="line">    其他成员...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X,Y,Z;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><ul><li>枚举类中的第一行，只能写枚举类的对象名称，且要用逗号隔开。</li><li>枚举类都是最终类，不可以被继承，枚举类都是继承java.lang.Enum类的。</li><li><font color=red>这些名称，本质是常量 ，每个常量都记住了枚举类的一个对象。</font></li><li>枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举类不能对外创建对象。</li><li>编译器为枚举类新增了几个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书接上回：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A a1=A.X;</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">        A a2=A.Y;</span><br><span class="line">        System.out.println(a2);</span><br><span class="line"></span><br><span class="line">        System.out.println(a1.name()); <span class="comment">//名称X</span></span><br><span class="line">        System.out.println(a2.name()); <span class="comment">//名称Y</span></span><br><span class="line">        System.out.println(a1.ordinal()); <span class="comment">//索引0</span></span><br><span class="line">        System.out.println(a2.ordinal()); <span class="comment">//索引1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举类的常见应用场景"><a href="#枚举类的常见应用场景" class="headerlink" title="枚举类的常见应用场景"></a>枚举类的常见应用场景</h3><ul><li>枚举类很适合做信息分类和标志。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        move(Direction.UP);</span><br><span class="line">        move(Direction.DOWN);</span><br><span class="line">        move(Direction.LEFT);</span><br><span class="line">        move(Direction.RIGHT);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(Direction d)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (d)&#123;</span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                System.out.println(<span class="string">&quot;向上移动&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                System.out.println(<span class="string">&quot;向下移动&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT:</span><br><span class="line">                System.out.println(<span class="string">&quot;向左移动&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT:</span><br><span class="line">                System.out.println(<span class="string">&quot;向右移动&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    UP,DOWN,LEFT,RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="认识抽象类"><a href="#认识抽象类" class="headerlink" title="认识抽象类"></a>认识抽象类</h3><ul><li><p>Java中有个关键字叫：<font color=red>abstract</font>，它就是抽象的意思，可以用它<font color=red>修饰类、成员方法</font>。</p><ul><li><font color=red>abstract</font>修饰类，这个类就是<font color=red>抽象类</font>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">    修饰符 <span class="keyword">abstract</span> 返回值类型 方法名称(形参列表);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color=red>abstrat</font>修饰方法，这个方法就是<font color=red>抽象方法</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"> <span class="comment">//抽象方法：必须abstract修饰，只有方法签名，不能有方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="抽象类的注意事项、特点"><a href="#抽象类的注意事项、特点" class="headerlink" title="抽象类的注意事项、特点"></a>抽象类的注意事项、特点</h3><ul><li><p>抽象类中不一定要有抽象方法，<mark>有抽象方法的类必须是抽象类</mark></p></li><li><p>抽象类就是为了被继承，作为父类（不能创建对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类有的成员：成员变量、方法、构造器，抽象类都可以有。</p></li><li><p><font color=crimson><strong>抽象类最主要的特点：</strong>抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现</font>。</p></li><li><p>一个类继承抽象类，必须重写完抽象类的<mark>全部</mark>抽象方法，否则这个类也必须定义为抽象类。</p></li></ul><h3 id="使用抽象类的好处"><a href="#使用抽象类的好处" class="headerlink" title="使用抽象类的好处"></a>使用抽象类的好处</h3><ul><li>父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现，<font color=red>我们设计这样的抽象类，就是为了更好的支持多态</font>。</li></ul><h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><ul><li>提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现。</li><li>模板方法设计模式可以：提高代码的复用、并简化子类设计。</li></ul><h4 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h4><ul><li>1、定义一个抽象类。</li><li>2、在里面定义2个方法：<ul><li><font color=red>一个是模板方法：把共同的实现步骤放里面去。</font></li><li>一个是抽象方法：不确定的实现步骤，交给<font color=red>具体的子类来完成</font>(重写抽象方法)</li></ul></li><li>建议使用final关键字修饰模板方法<ul><li>模板方法是给子类直接使用的，不能被子类重写。</li><li>一旦子类重写了模板方法，模板方法就失效了。</li></ul></li></ul><hr><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="认识接口"><a href="#认识接口" class="headerlink" title="认识接口"></a>认识接口</h3><h4 id="接口的概述"><a href="#接口的概述" class="headerlink" title="接口的概述"></a>接口的概述</h4><ul><li><p>Java提供了一个关键字interface定义出接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统接口（JDK8之前）</span></span><br><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//成员变量（常量）</span></span><br><span class="line">    <span class="comment">//成员方法（抽象方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、常量：接口中定义常量可以省略public static final不写，默认会加上去。</li><li>2、抽象方法：接口中定义抽象方法可以省略public abstract 不写，默认会加上去。</li></ul></li><li><p>注意：接口不能创建对象。</p></li><li><p>接口时用来被类实现(implements)的，实现接口的类称为      <font color=red>实现类，一个类可以同时实现多个接口</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 实现类类名 implements 接口<span class="number">1</span>,接口<span class="number">2.</span>..&#123;</span><br><span class="line">    <span class="comment">//实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义为抽象类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接口好处"><a href="#接口好处" class="headerlink" title="接口好处"></a>接口好处</h3><ul><li>弥补了类单继承的不足，一个类同时可以实现多个接口，使类的角色更多，功能更强大。</li><li>让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现(更利于程序的解耦合(模块化))</li></ul><h3 id="JDK8开始，接口新增的三种方法"><a href="#JDK8开始，接口新增的三种方法" class="headerlink" title="JDK8开始，接口新增的三种方法"></a>JDK8开始，接口新增的三种方法</h3><h4 id="认识新增的三种方法"><a href="#认识新增的三种方法" class="headerlink" title="认识新增的三种方法"></a>认识新增的三种方法</h4><ul><li><p>1、默认方法（实例方法）：使用default修饰，默认会被加上public修饰。</p><ul><li>注意：只能使用接口的实现类对象调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2、私有方法：必须使用private修饰(JDK9才开始支持)</p><ul><li>只能使用接口中的其他实力哦方法来调用它</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3、类方法（静态方法）：使用static修饰，默认会被加上public修饰。</p><ul><li>注意：只能用当前接口名来调用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用：增强了接口的能力，便于项目的扩展和维护。</p></li></ul><h3 id="接口的几点注意事项"><a href="#接口的几点注意事项" class="headerlink" title="接口的几点注意事项"></a>接口的几点注意事项</h3><ul><li>1、接口和接口可以多继承：一个接口可以同时继承多个接口(重点)</li><li>2、一个接口继承多个和接口，如果多个接口中存在方法签名冲突，则此时不支持多继承，也不支持多实现(了解)。</li><li>3、一个类继承了父类，有同时实现了接口，如果父类中和接口中有同名的默认方法，实现类会优先用父类的。</li><li>4、一个类实现了多个接口，如果多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。</li></ul><hr><h3 id="抽象类与接口的对比"><a href="#抽象类与接口的对比" class="headerlink" title="抽象类与接口的对比"></a>抽象类与接口的对比</h3><ul><li>相同点：<ul><li>1、都是抽象形式，都可以有抽象方法，都不能创建对象。</li><li>2、都是派生子类形式：抽象类是被子类继承使用，接口是被实现类实现。</li><li>3、一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则自己要成为抽象类或者报错</li><li>4、都能支持多态，都能够实现解耦合。</li></ul></li><li>不同点：<ul><li>1、抽象类中可以定义类的全部成员，接口只能定义常量，抽象方法（JDK8新增的三种方法）</li><li>2、抽象类只能被类单继承，接口可以被类多实现。</li><li>3、一个类继承抽象类就不能再继承其他类，一个类实现了接口（还可以继承其他类或者实现其他接口）</li><li>4、抽象类体现模板思想：更利于做父类，实现代码的复用性。（最佳实践）</li><li>5、接口更适合做功能的解耦合：解耦合性更强更灵活。（最佳实践）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象之——多态</title>
      <link href="/2025/12/20/%E5%A4%9A%E6%80%81/"/>
      <url>/2025/12/20/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="1-认识多态"><a href="#1-认识多态" class="headerlink" title="1.认识多态"></a>1.认识多态</h2><h3 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h3><ul><li>多态是在<font color=red>继承&#x2F;实现</font>情况下的一种现象，表现为：对象多态、行为多态。</li></ul><h4 id="多态的具体代码体现："><a href="#多态的具体代码体现：" class="headerlink" title="多态的具体代码体现："></a><strong>多态的具体代码体现：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">People p1= <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">r1.run();</span><br><span class="line"></span><br><span class="line">People p2=<span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">p2.run();</span><br></pre></td></tr></table></figure><h3 id="多态的前提："><a href="#多态的前提：" class="headerlink" title="多态的前提："></a>多态的前提：</h3><ul><li>有<font color=red>继承&#x2F;实现</font>关系；</li><li>存在父类引用子类对象；</li><li><font color=red>存在方法重写</font>。&#x2F;&#x2F;导致每个对象的行为不一样</li></ul><h3 id="多态的一个注意事项"><a href="#多态的一个注意事项" class="headerlink" title="多态的一个注意事项"></a>多态的一个注意事项</h3><ul><li>多态是对象、行为的多态</li><li>Java中的属性(成员变量)不谈多态。<ul><li>对于方法：编译看左边，运行看右边；</li><li>对于成员变量：编译看左边，运行也看左边。</li></ul></li></ul><hr><h2 id="2-多态的好处"><a href="#2-多态的好处" class="headerlink" title="2.多态的好处"></a>2.多态的好处</h2><h3 id="使用多态的好处"><a href="#使用多态的好处" class="headerlink" title="使用多态的好处"></a>使用多态的好处</h3><ul><li><p>在多态形式下，右边对象是解耦合(模块化)的，更便于扩展和维护</p></li><li><p>定义方法时，使用父亲类型的形参，可以接收一切子类对象，扩展性更强、更便利。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Animal a1=<span class="keyword">new</span> <span class="title class_">Sheep</span>();</span><br><span class="line">        a1.run();</span><br><span class="line">        go(a1);</span><br><span class="line">        Animal a2=<span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">        a2.run();</span><br><span class="line">        go(a2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Animal a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始。。。&quot;</span>);</span><br><span class="line">        a.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态下会产生的一个问题"><a href="#多态下会产生的一个问题" class="headerlink" title="多态下会产生的一个问题"></a>多态下会产生的一个问题</h3><ul><li>多态下不能使用子类的独有功能。</li></ul><hr><h2 id="3-多态下的类型转换"><a href="#3-多态下的类型转换" class="headerlink" title="3.多态下的类型转换"></a>3.多态下的类型转换</h2><h3 id="转换形式："><a href="#转换形式：" class="headerlink" title="转换形式："></a>转换形式：</h3><ul><li>自动类型转换：父类 变量名 &#x3D;new 子类();</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People p=<span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br></pre></td></tr></table></figure><ul><li>强制类型转换：<font color=red>子类 变量名&#x3D;(子类)父类变量</font><ul><li>解决多态下调用子类独有功能。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher t=(Teacher)p;</span><br></pre></td></tr></table></figure><h3 id="强制转换的一个注意事项："><a href="#强制转换的一个注意事项：" class="headerlink" title="强制转换的一个注意事项："></a>强制转换的一个注意事项：</h3><ul><li>存在继承&#x2F;实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。</li><li>运行时，如果发现对象的真实类型与强转后的类型不同，就会类型转换异常(ClassCastException)的错误出来。</li></ul><h5 id="强转前，Java建议："><a href="#强转前，Java建议：" class="headerlink" title="强转前，Java建议："></a>强转前，Java建议：</h5><ul><li>使用 <strong>instanceof</strong> 关键字，判断当前对象的真实类型，在进行强转。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">instanceof</span> Student</span><br><span class="line"><span class="comment">//对象 instanceif 类型</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的基本语法</title>
      <link href="/2025/12/20/%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/12/20/%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="类的基本语法"><a href="#类的基本语法" class="headerlink" title="类的基本语法"></a>类的基本语法</h1><blockquote><p>Java learning note</p><p>Written by XuX</p></blockquote><h2 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1.构造器"></a>1.构造器</h2><p>构造器，就是名字和类名一致，并且没有定义返回值的一种特殊方法。</p><h4 id="构造器长什么样？如下代码所示："><a href="#构造器长什么样？如下代码所示：" class="headerlink" title="构造器长什么样？如下代码所示："></a>构造器长什么样？如下代码所示：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参数构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">/*类中的构造器*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123; <span class="comment">//只有修饰符，没有返回值（特殊形式）</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.有参数构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器有什么特点呢？"><a href="#构造器有什么特点呢？" class="headerlink" title="构造器有什么特点呢？"></a>构造器有什么特点呢？</h4><p>创建对象时，<u>对象会调用构造器</u>，我们可以指定对象去调用哪个构造器去执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line">Student s=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><h4 id="构造器的常见应用场景："><a href="#构造器的常见应用场景：" class="headerlink" title="构造器的常见应用场景："></a>构造器的常见应用场景：</h4><p>创建对象时，同时完成对对象成员变量(属性)的初始化赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="comment">//有参数构造器：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String n,<span class="type">int</span> a,<span class="type">char</span> g)</span>&#123;</span><br><span class="line">        name=n;</span><br><span class="line">        age=a;</span><br><span class="line">        gender=g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象调用：</span></span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;kobe&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="构造器的注意事项："><a href="#构造器的注意事项：" class="headerlink" title="构造器的注意事项："></a>构造器的注意事项：</h4><p>1.类默认就自带了一个无参构造器；</p><p>2.如果为类定义了有参数构造器，类默认的无参数构造器就没有了，若还想用无参数构造器，就必须自己手写一个无参数构造器出来。</p><p>3.要么都不写，要么都写（无参数在开发中别人可能会使用）</p><hr><h2 id="2-this关键字"><a href="#2-this关键字" class="headerlink" title="2. this关键字"></a>2. this关键字</h2><h4 id="this-关键字是什么？"><a href="#this-关键字是什么？" class="headerlink" title="this 关键字是什么？"></a>this 关键字是什么？</h4><p>this就是一个变量，可以用在方法中，来拿到当前对象</p><p><u>哪个对象调用这个方法，this就拿到哪个对象(取地址)</u></p><h4 id="this有哪些应用场景？"><a href="#this有哪些应用场景？" class="headerlink" title="this有哪些应用场景？"></a>this有哪些应用场景？</h4><p>this主要用来<u>解决：变量名称冲突问题</u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name; <span class="comment">//成员变量(整个对象都可以用)    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHobby</span><span class="params">(String name)</span>&#123; <span class="comment">//局部变量(方法内部)</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;喜欢&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h2><h4 id="什么是封装？"><a href="#什么是封装？" class="headerlink" title="什么是封装？"></a>什么是封装？</h4><p>就是用类设计对象处理某一个事务的数据时，应该把要处理的数据，以及处理这些数据的方法，设计到一个对象中去</p><p><em><em>面向对象的三大特征：<strong>封装</strong>，继承，多态</em></em></p><h4 id="封装的设计要求："><a href="#封装的设计要求：" class="headerlink" title="封装的设计要求："></a>封装的设计要求：</h4><p>合理隐藏，合理暴露。</p><h5 id="1-如何隐藏对象的成员？"><a href="#1-如何隐藏对象的成员？" class="headerlink" title="1.如何隐藏对象的成员？"></a>1.如何隐藏对象的成员？</h5><p>使用private关键字(私有，隐藏)修饰成员变量，就只能在本类中被直接访问，其他任何地方不能直接访问</p><h5 id="2-如何暴露对象的成员（合理暴露）？"><a href="#2-如何暴露对象的成员（合理暴露）？" class="headerlink" title="2.如何暴露对象的成员（合理暴露）？"></a>2.如何暴露对象的成员（合理暴露）？</h5><p>使用public(公开)的get和set方法合理暴露，成员变量的取值和赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="comment">//1.为年龄赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(age&gt;<span class="number">0</span>&amp;&amp;age&lt;<span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您赋值的年龄数据非法！&quot;</span>);   <span class="comment">//例如web端对于输入的年龄的校验</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用：</span></span><br><span class="line">s1.setAge(<span class="number">18</span>); <span class="comment">//赋值18；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.为年龄取值：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用：</span></span><br><span class="line">System.out.println(s1.getAge()); <span class="comment">//取值</span></span><br></pre></td></tr></table></figure><h5 id="总结（代码层面如何控对象的成员的公开与与隐藏？）"><a href="#总结（代码层面如何控对象的成员的公开与与隐藏？）" class="headerlink" title="总结（代码层面如何控对象的成员的公开与与隐藏？）:"></a>总结（代码层面如何控对象的成员的公开与与隐藏？）:</h5><ul><li>公开成员，可以使用public(公开)进行修饰。</li><li>隐藏成员，使用private(私有，隐藏)进行修饰</li></ul><hr><h2 id="4-实体类-特殊类-Javabean"><a href="#4-实体类-特殊类-Javabean" class="headerlink" title="4.实体类(特殊类) Javabean"></a>4.实体类(特殊类) Javabean</h2><h4 id="1-是一种特殊类，类中要满足如下需求："><a href="#1-是一种特殊类，类中要满足如下需求：" class="headerlink" title="1.是一种特殊类，类中要满足如下需求："></a>1.是一种特殊类，类中要满足如下需求：</h4><p>1.类中的成员变量全部私有，并提供public修饰的getter&#x2F;setter方法；</p><p>2.类中要提供一个无参数的构造器，有参数构造器可选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实体类的作用：创建它的对象，存取（封装）数据</span></span><br><span class="line">        <span class="comment">//调用无参构造器的对象</span></span><br><span class="line">        Student s=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//调用有参构造器的对象</span></span><br><span class="line">        Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//2.提供公平的getter和setter方法，暴露其取值和赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须提供一个无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个有参构造器（可选）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-实体类有啥应用场景？"><a href="#2-实体类有啥应用场景？" class="headerlink" title="2.实体类有啥应用场景？"></a>2.实体类有啥应用场景？</h4><ul><li>实体类的对象<u>只负责数据读取</u>，而对数据的业务处理交给其他类的对象来完成，以<u>实现数据</u>和<u>数据业务处理</u>相分离。(分层思想)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student s; <span class="comment">//用来记住将来要操作的学生对象 （null）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentOperator</span><span class="params">(Student s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.Student=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印总成绩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> printscore&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印平均成绩</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        <span class="comment">//创建一个学生的操作对象专门负责对学生对象的数据进行业务分析</span></span><br><span class="line">        StudentOperate op=<span class="keyword">new</span> <span class="title class_">StudentOperate</span>(s1);</span><br><span class="line">        op.printscore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><h4 id="1-什么是实体类？有什么特点？"><a href="#1-什么是实体类？有什么特点？" class="headerlink" title="1.什么是实体类？有什么特点？"></a>1.什么是实体类？有什么特点？</h4><ul><li>成员变量必须私有，且要为它们提供get、set方法；必须有无参数构造器</li><li>仅仅是一个用来保存数据的Java类，可以用它来创建对象，保存某个事物的数据</li></ul><h4 id="2-实体类的应用场景-如上"><a href="#2-实体类的应用场景-如上" class="headerlink" title="2.实体类的应用场景(如上)"></a>2.实体类的应用场景(如上)</h4><hr><h2 id="4-static"><a href="#4-static" class="headerlink" title="4. static"></a>4. static</h2><h3 id="1-static-修饰成员变量"><a href="#1-static-修饰成员变量" class="headerlink" title="1. static 修饰成员变量"></a>1. static 修饰成员变量</h3><h4 id="成员变量按照有无static修饰，分为两种："><a href="#成员变量按照有无static修饰，分为两种：" class="headerlink" title="成员变量按照有无static修饰，分为两种："></a>成员变量按照有无static修饰，分为两种：</h4><ul><li><p>静态变量（类变量）：有static修饰，属于类，在计算机里只有一份，会被类的全部对象共享。</p><p><u>访问方式：类名.静态对象</u></p><p>也可以以“对象名.静态变量”的方式（语法上不推荐 ）</p></li><li><p>实例变量（对象的变量）：无static修饰，属于每个对象的。</p><p><u>访问方式：对象.实例变量</u></p><p><mark>注意：不允许使用this关键字</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量：属于类，只加载一份，可以被类和类的全部对象共享访问</span></span><br><span class="line">    <span class="keyword">static</span> String name;  <span class="comment">//先进入堆内存null</span></span><br><span class="line">    <span class="comment">//实例变量（对象的变量）：属于对象，每个对象一份</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="静态变量应用场景："><a href="#静态变量应用场景：" class="headerlink" title="静态变量应用场景："></a>静态变量应用场景：</h4><ul><li><p>如果某个数据只需要一份，且希望能够被共享（修改&#x2F;访问），则该数据可以定义为静态变量来记住</p></li><li><p>例如：记录用户类创建了多少用户对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        User.number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问自己类中的类变量，可以省略类名不写"><a href="#访问自己类中的类变量，可以省略类名不写" class="headerlink" title="访问自己类中的类变量，可以省略类名不写"></a>访问自己类中的类变量，可以省略类名不写</h4><p>注意：在某类中访问其他类里的类变量必须带类名访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String school=<span class="string">&quot;HUT&quot;</span>;<span class="comment">//类变量（静态变量）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSchool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//本类内访问类变量，可省略类名Student</span></span><br><span class="line">        System.out.println(school);</span><br><span class="line">                         <span class="comment">//等价于Student.school</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-static修饰方法"><a href="#2-static修饰方法" class="headerlink" title="2. static修饰方法"></a>2. static修饰方法</h3><h4 id="使用规范："><a href="#使用规范：" class="headerlink" title="使用规范："></a>使用规范：</h4><p><mark>1.如果这个方法只是为了做一个功能且不需要直接访问对象的数据，那么这个方法应该定义为静态方法</mark></p><p><mark>2.如果这个方法是对象的行为，需要访问对象数据，那么这个方法应该定义为实例方法</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//认识 static修饰与不修饰方法的区别</span></span><br><span class="line">        <span class="comment">//1.类名.静态方法（推荐）</span></span><br><span class="line">        Student.printHelloWorld();</span><br><span class="line">        <span class="comment">//2.对象.静态方法（不推荐）</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.printHelloWorld();</span><br><span class="line">        <span class="comment">//3.对象名.实例方法</span></span><br><span class="line">        <span class="comment">//Student.printPass(); //报错</span></span><br><span class="line">        s1.setScore(<span class="number">59.9</span>);</span><br><span class="line">        s1.printPass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//静态方法:有static修饰，属于类持有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例方法:无static修饰，属于对象持有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPass</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(score&gt;=<span class="number">60</span>?<span class="string">&quot;通过&quot;</span>:<span class="string">&quot;挂科了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态方法的应用"><a href="#3-静态方法的应用" class="headerlink" title="3.静态方法的应用"></a>3.静态方法的应用</h3><h4 id="静态方法常见的应用场景"><a href="#静态方法常见的应用场景" class="headerlink" title="静态方法常见的应用场景"></a>静态方法常见的应用场景</h4><ul><li>做工具类</li></ul><h4 id="工具类是什么？"><a href="#工具类是什么？" class="headerlink" title="工具类是什么？"></a>工具类是什么？</h4><ul><li>工具类中的方法都是一些静态方法，每个方法用来完成一项功能，以便于开发者直接使用。</li></ul><h4 id="使用类方法来设计工具类有啥好处？"><a href="#使用类方法来设计工具类有啥好处？" class="headerlink" title="使用类方法来设计工具类有啥好处？"></a>使用类方法来设计工具类有啥好处？</h4><ul><li>提高了代码复用；</li><li>调用方便，提高了开发的效率</li></ul><p><strong>注意：<u>工具类没有创建对象的需求（占内存），建议将工具类的构造器进行私有</u></strong></p><h3 id="4-static的注意事项"><a href="#4-static的注意事项" class="headerlink" title="4. static的注意事项"></a>4. static的注意事项</h3><ul><li>静态方法中可以直接访问静态成员不可以直接访问实例成员</li><li>实例方法中既可以直接访问静态成员，也可以直接访问实例成员</li><li>实例方法中可以出现this关键字，静态方法中不可以出现this关键字的</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象之——继承</title>
      <link href="/2025/12/20/%E7%BB%A7%E6%89%BF/"/>
      <url>/2025/12/20/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="1-认识继承"><a href="#1-认识继承" class="headerlink" title="1.认识继承"></a>1.认识继承</h2><h3 id="为什么要有继承？"><a href="#为什么要有继承？" class="headerlink" title="为什么要有继承？"></a>为什么要有继承？</h3><ul><li>提高代码的重用性，减少一点重复代码的书写</li></ul><h3 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a>什么是继承？</h3><ul><li>Java中提供了一个关键字extends，用这个关键字，可以让一个类与另一个类建立起父子关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//A类称为父类（基类或超类）</span></span><br><span class="line">    <span class="comment">//B类称为子类（派生类）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子类能继承啥？"><a href="#子类能继承啥？" class="headerlink" title="子类能继承啥？"></a>子类能继承啥？</h4><ul><li>子类能继承父类的非私有成员变量（成员变量、成员方法）</li></ul><h4 id="继承后对象的创建"><a href="#继承后对象的创建" class="headerlink" title="继承后对象的创建"></a>继承后对象的创建</h4><ul><li>子类的对象是由子类、父类共同完成的。</li></ul><hr><h2 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2.权限修饰符"></a>2.权限修饰符</h2><h3 id="什么是权限修饰符？"><a href="#什么是权限修饰符？" class="headerlink" title="什么是权限修饰符？"></a>什么是权限修饰符？</h3><ul><li><p>就是用来限制类中的成员（成员变量、成员方法、构造器）能够访问的范围。</p><p><mark>private</mark>：只能本类</p><p><mark>缺省(不写任何权限修饰符，默认权限)</mark>：本类、同一个包中的类</p><p><mark>protected</mark>：本类，同一个包的类，子孙类中</p><p><mark>public</mark>：任意位置</p></li></ul><hr><h2 id="3-继承的特点"><a href="#3-继承的特点" class="headerlink" title="3.继承的特点"></a>3.继承的特点</h2><h3 id="1-单继承"><a href="#1-单继承" class="headerlink" title="1)单继承"></a>1)单继承</h3><ul><li>Java是单继承模式：一个类只能继承一个直接父类</li></ul><h3 id="2-多层继承"><a href="#2-多层继承" class="headerlink" title="2)多层继承"></a>2)多层继承</h3><ul><li>Java不支持多继承，但支持多层继承</li></ul><h3 id="3-祖宗类"><a href="#3-祖宗类" class="headerlink" title="3)祖宗类"></a>3)祖宗类</h3><ul><li>Java中所有的类都是Object的子类，Object是所有类的祖宗类</li><li>Java中所有类，要么直接继承了Object，要么默认继承了Object，要么间接继承了Object</li></ul><h3 id="4-就近原则"><a href="#4-就近原则" class="headerlink" title="4)就近原则"></a>4)就近原则</h3><h4 id="1、子类方法中访问其他成员（成员变量、成员方法），依照就近原则"><a href="#1、子类方法中访问其他成员（成员变量、成员方法），依照就近原则" class="headerlink" title="1、子类方法中访问其他成员（成员变量、成员方法），依照就近原则"></a>1、子类方法中访问其他成员（成员变量、成员方法），依照就近原则</h4><ul><li>优先访问自己类中，自己类中的没有才会访问父类</li><li>先子类的局部范围找，然后子类的成员范围找，然后父类成员范围找，如果父类范围没找到就报错。</li></ul><h4 id="2、如果子父类，出现了重名的成员，会优先使用子类的，如果一定要在子类中使用父类的怎么办？"><a href="#2、如果子父类，出现了重名的成员，会优先使用子类的，如果一定要在子类中使用父类的怎么办？" class="headerlink" title="2、如果子父类，出现了重名的成员，会优先使用子类的，如果一定要在子类中使用父类的怎么办？"></a>2、如果子父类，出现了重名的成员，会优先使用子类的，如果一定要在子类中使用父类的怎么办？</h4><ul><li>可以使用<font color=red>super关键字</font>，指定访问父类的成员：</li></ul><p>​        <font color=red><strong>super.父类成员变量&#x2F;父类成员方法</strong></font></p><hr><h2 id="4-方法重写"><a href="#4-方法重写" class="headerlink" title="4.方法重写"></a>4.方法重写</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>当子类觉得父类中的某个方法不好用，或者是无法满足自己的需求时，子类可以重写一个<u>方法名称、参数列表一样的方法</u>，去覆盖父类这个方法，这就是方法重写。</p></li><li><p>方法名称，形参列表必须一样，这种方法就是方法重写。</p></li></ul><h3 id="重写小技巧："><a href="#重写小技巧：" class="headerlink" title="重写小技巧："></a>重写小技巧：</h3><ul><li>使用<font color=red>Override注解</font>，它可以指定Java编译器，检查我们的方法重写格式是否正确，代码的可读性也会更好。</li><li>声明不变，重新实现。</li></ul><h3 id="方法重写的其他注意事项"><a href="#方法重写的其他注意事项" class="headerlink" title="方法重写的其他注意事项"></a>方法重写的其他注意事项</h3><ul><li>子类重写父类方法时，访问权限必须大于或等于父类该方法的权限<font  color=red>(public&gt;protected&gt;缺省)</font></li><li>重写的方法返回值类型，必须与重写方法的返回值类型一样，或者范围更小。</li><li>私有方法、静态方法不能被重写，如果重写会报错。</li></ul><h3 id="方法重写再开发中的常见应用场景"><a href="#方法重写再开发中的常见应用场景" class="headerlink" title="方法重写再开发中的常见应用场景"></a>方法重写再开发中的常见应用场景</h3><ul><li><p>子类重写Object类的toString()方法，以便返回对象的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student s=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;kobe&quot;</span>,<span class="number">5</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(s.toString());</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//注意1：直接输出对象，默认会调用toString方法，返回对象的地址信息</span></span><br><span class="line">        <span class="comment">//注意2：输出对象的地址没有意义，开发中更希望看到的是对象的信息，所以子类需要重写Object的toString方法</span></span><br><span class="line">        <span class="comment">//      以便以后输出对象时默认调用子类重写的toSring方法返回对象的内容。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, gender=&quot;</span> + gender +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意1：直接输出对象，默认会调用toString方法，返回对象的地址信息</p></li><li><p>注意2：输出对象的地址没有意义，开发中更希望看到的是对象的信息，所以子类需要重写Object的toString方法，以便以后输出对象时默认调用子类重写的toSring方法返回对象的内容。</p></li></ul><hr><h2 id="5-子类构造器的特点"><a href="#5-子类构造器的特点" class="headerlink" title="5.子类构造器的特点"></a>5.子类构造器的特点</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>子类的全部构造器，都会先调用父类的构造器，再执行自己。</li></ul><h3 id="子类构造器是如何实现调用父类构造器的："><a href="#子类构造器是如何实现调用父类构造器的：" class="headerlink" title="子类构造器是如何实现调用父类构造器的："></a>子类构造器是如何实现调用父类构造器的：</h3><ul><li><p>默认情况下，子类全部构造器的第一行代码都是<font color=red>super()（写不写都有），它会调用父类的无参数构造器</font></p></li><li><p>如果父类没有无参数构造器，则我们必须在子类构造器第一行手写super(…)，指定去调用父类的有参数构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//子类构造器都会先调用父类无参数构造器，再执行自己的构造器</span></span><br><span class="line">        Zi zi=<span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">666</span>); <span class="comment">//指定调用父类的有参构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类有参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="子类构造器调用父类构造器的应用场景"><a href="#子类构造器调用父类构造器的应用场景" class="headerlink" title="子类构造器调用父类构造器的应用场景"></a>子类构造器调用父类构造器的应用场景</h3><ul><li>子类构造器可以通过调用父类构造器，把对象中包含父类这部分的数据先初始化赋值。</li><li>再回来把对象里包含子类这部分的数据也进行初始化赋值。</li></ul><h3 id="补充知识：this-…-调用兄弟构造器"><a href="#补充知识：this-…-调用兄弟构造器" class="headerlink" title="补充知识：this(…)调用兄弟构造器"></a>补充知识：this(…)调用兄弟构造器</h3><ul><li><p>任意类的构造器中，是可以通过this(…)去调用该类的其他构造器的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> gender)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name,age,gender,<span class="string">&quot;HUT&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：super(…)和this(…)必须写在构造器的第一行，而且两者不能同时出现。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
